<?xml version="1.0" encoding="UTF-8"?>
<root>
<title>JVM内存分配机制</title>
<content>&amp;lt;p&amp;gt;
	通过这几天对一个内存溢出程序的监控，学习了程序运行时对内存的使用机制，在这里和大家分享下。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java程序运行在JVM(Java&amp;nbsp;&amp;nbsp;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	Virtual&amp;nbsp;Machine，Java虚拟机)上，可以把JVM理解成Java程序和操作系统之间的桥梁，JVM实现了Java的平台无关性，由此可
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	见JVM的重要性。所以在学习Java内存分配原理的时候一定要牢记这一切都是在JVM中进行的，JVM是内存分配原理的基础与前提。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一个完整的Java程序运行过程会涉及以下内存区域：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;寄存器：JVM内部虚拟寄存器，存取速度非常快，程序不可控制。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;栈：保存局部变量的值，包括：a.用来保存基本数据类型的值；b.保存类的实例，即堆区对象的引用(指针)。也可以用来保存加载方法时的帧。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;堆：用来存放动态产生的数据，比如new出来的对象。注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用(1)。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码段：用来存放从硬盘上读取的源程序代码。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据段：用来存放static定义的静态成员。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	下图表示内存分配图：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;lt;img&amp;nbsp;src=\"/mod/kd/attached/image/20120613/20120613225046_77667.jpg\"&amp;nbsp;alt=\"\"&amp;nbsp;/&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;lt;p&amp;gt;
		对于java&amp;nbsp;和内存之间，有如下几点需要注意：
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		1.一个Java文件，只要有main入口方法，我们就认为这是一个Java程序，可以单独编译运行。
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;nbsp;2.无
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而引
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此，普通类型变量只在栈区占用一块内存，而引用类型变量
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		要在栈区和堆区各占一块内存。
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		3.分清什么是实例什么是对象。Class&amp;nbsp;a=&amp;nbsp;new&amp;nbsp;Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		4.栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		5.以上的栈、堆、代码段、数据段等等都是相对于应用程序而言的。每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		6&amp;nbsp;.类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。
	&amp;lt;/p&amp;gt;
&amp;lt;/p&amp;gt;</content>
<json-link>./file/java/2012-06-13/1339599144.json</json-link>
<comment-link>4</comment-link>
<tags>5</tags>
<imghref/>
<comment-list>
 <c>
  <author-c>1</author-c>
  <uid-c>2</uid-c>
  <date-c>2</date-c>
  <conf-c>3</conf-c>
  <locked>true</locked>
 </c>
</comment-list>
</root>
