<?xml version="1.0" encoding="UTF-8"?>
<root>
<title>C语言中可变参数的用法</title>
<content>&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	我们在C语言编程中会遇到一些参数个数可变的函数,例如printf()这个函数,它的定义是这样的:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	int&amp;nbsp;printf(&amp;nbsp;const&amp;nbsp;char*&amp;nbsp;format,&amp;nbsp;...);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的,例如我们可以有以下不同的调用方法:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	printf(\"%d\",i);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	printf(\"%s\",s);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	printf(\"the&amp;nbsp;number&amp;nbsp;is&amp;nbsp;%d&amp;nbsp;,string&amp;nbsp;is:%s\",&amp;nbsp;i,&amp;nbsp;s);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	究竟如何写可变参数的C函数以及这些可变参数的函数编译器是如何实现的呢?本文就这个问题进行一些探讨,希望能对大家有些帮助.会C++的网友知道这些问题在C++里不存在,因为C++具有多态性.但C++是C的一个超集,以下的技术也可以用于C++的程序中.限于本人的水平,文中如果有不当之处,请大家指正.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	(一)写一个简单的可变参数的C函数
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	下面我们来探讨如何写一个简单的可变参数的C函数.写可变参数的C函数要在程序中用到以下这些宏:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	void&amp;nbsp;va_start(&amp;nbsp;va_list&amp;nbsp;arg_ptr,&amp;nbsp;prev_param&amp;nbsp;);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	type&amp;nbsp;va_arg(&amp;nbsp;va_list&amp;nbsp;arg_ptr,&amp;nbsp;type&amp;nbsp;);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	void&amp;nbsp;va_end(&amp;nbsp;va_list&amp;nbsp;arg_ptr&amp;nbsp;);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	va在这里是variable-argument(可变参数)的意思.这些宏定义在stdarg.h中,所以用到可变参数的程序应该包含这个头文件.下面我们写一个简单的可变参数的函数,改函数至少有一个整数参数,第二个参数也是整数,是可选的.函数只是打印这两个参数的值.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	void&amp;nbsp;simple_va_fun(int&amp;nbsp;i,&amp;nbsp;...)
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	{
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	va_list&amp;nbsp;arg_ptr;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	int&amp;nbsp;j=0;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	va_start(arg_ptr,&amp;nbsp;i);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	j=va_arg(arg_ptr,&amp;nbsp;int);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	va_end(arg_ptr);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	printf(\"%d&amp;nbsp;%d\n\",&amp;nbsp;i,&amp;nbsp;j);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	return;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	}
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	我们可以在我们的头文件中这样声明我们的函数:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	extern&amp;nbsp;void&amp;nbsp;simple_va_fun(int&amp;nbsp;i,&amp;nbsp;...);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	我们在程序中可以这样调用:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	simple_va_fun(100);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	simple_va_fun(100,200);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	从这个函数的实现可以看到,我们使用可变参数应该有以下步骤:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	1)首先在函数里定义一个va_list型的变量,这里是arg_ptr,这个变量是指向参数的指针.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	2)然后用va_start宏初始化变量arg_ptr,这个宏的第二个参数是第一个可变参数的前一个参数,是一个固定的参数.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	3)然后用va_arg返回可变的参数,并赋值给整数j.&amp;nbsp;va_arg的第二个参数是你要返回的参数的类型,这里是int型.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	4)最后用va_end宏结束可变参数的获取.然后你就可以在函数里使用第二个参数了.如果函数有多个可变参数的,依次调用va_arg获取各个参数.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	如果我们用下面三种方法调用的话,都是合法的,但结果却不一样:
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	1)
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	simple_va_fun(100);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	结果是:100&amp;nbsp;-123456789(会变的值)
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	2)　　simple_va_fun(100,200);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	结果是:100&amp;nbsp;200
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	3)　　simple_va_fun(100,200,300);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	结果是:100&amp;nbsp;200
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	我们看到第一种调用有错误,第二种调用正确,第三种调用尽管结果正确,但和我们函数最初的设计有冲突.下面一节我们探讨出现这些结果的原因和可变参数在编译器中是如何处理的.
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;nbsp;style=\"text-indent:2em;\"&amp;gt;
	&amp;lt;p&amp;gt;
		(二)可变参数在编译器中的处理
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		我们知道va_start,va_arg,va_end是在stdarg.h中被定义成宏的,由于1)硬件平台的不同&amp;nbsp;2)编译器的不同,所以定义的宏也有所不同,下面以VC++中stdarg.h里x86平台的宏定义摘录如下(’\’号表示折行):
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		typedef&amp;nbsp;char&amp;nbsp;*&amp;nbsp;va_list;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		#define&amp;nbsp;_INTSIZEOF(n)&amp;nbsp;\
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		((sizeof(n)+sizeof(int)-1)&amp;amp;~(sizeof(int)&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		#define&amp;nbsp;va_start(ap,v)&amp;nbsp;(&amp;nbsp;ap&amp;nbsp;=&amp;nbsp;(va_list)&amp;amp;v&amp;nbsp;+&amp;nbsp;_INTSIZEOF(v)&amp;nbsp;)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		#define&amp;nbsp;va_arg(ap,t)&amp;nbsp;\
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		(&amp;nbsp;*(t&amp;nbsp;*)((ap&amp;nbsp;+=&amp;nbsp;_INTSIZEOF(t))&amp;nbsp;-&amp;nbsp;_INTSIZEOF(t))&amp;nbsp;)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		#define&amp;nbsp;va_end(ap)&amp;nbsp;(&amp;nbsp;ap&amp;nbsp;=&amp;nbsp;(va_list)0&amp;nbsp;)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		定义_INTSIZEOF(n)主要是为了某些需要内存的对齐的系统.C语言的函数是从右向左压入堆栈的,图(1)是函数的参数在堆栈中的分布位置.我们看到va_list被定义成char*,有一些平台或操作系统定义为void*.再看va_start的定义,定义为&amp;amp;v+_INTSIZEOF(v),而&amp;amp;v是固定参数在堆栈的地址,所以我们运行va_start(ap,&amp;nbsp;v)以后,ap指向第一个可变参数在堆栈的地址,如图:
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		高地址&amp;brvbar;-----------------------------&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;函数返回地址&amp;nbsp;&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;-----------------------------&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;.......&amp;nbsp;&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;-----------------------------&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;第n个参数(第一个可变参数)&amp;nbsp;&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;-----------------------------&amp;brvbar;&amp;amp;lt;--va_start后ap指向
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;第n-1个参数(最后一个固定参数)&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		低地址&amp;brvbar;-----------------------------&amp;brvbar;&amp;amp;lt;--&amp;nbsp;&amp;amp;v
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		图(1)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		然后,我们用va_arg()取得类型t的可变参数值,以上例为int型为例,我们看一下va_arg取int型的返回值:
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		j=&amp;nbsp;(&amp;nbsp;*(int*)((ap&amp;nbsp;+=&amp;nbsp;_INTSIZEOF(int))-_INTSIZEOF(int))&amp;nbsp;);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		首先ap+=sizeof(int),已经指向下一个参数的地址了.然后返回ap-sizeof(int)的int*指针,这正是第一个可变参数在堆栈里的地址(图2).然后用*取得这个地址的内容(参数值)赋给j.
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		高地址&amp;brvbar;-----------------------------&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;函数返回地址&amp;nbsp;&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;-----------------------------&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;.......&amp;nbsp;&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;-----------------------------&amp;brvbar;&amp;amp;lt;--va_arg后ap指向
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;第n个参数(第一个可变参数)&amp;nbsp;&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;-----------------------------&amp;brvbar;&amp;amp;lt;--va_start后ap指向
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;brvbar;第n-1个参数(最后一个固定参数)&amp;brvbar;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		低地址&amp;brvbar;-----------------------------&amp;brvbar;&amp;amp;lt;--&amp;nbsp;&amp;amp;v
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		图(2)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		最后要说的是va_end宏的意思,x86平台定义为ap=(char*)0;使ap不再指向堆栈,而是跟NULL一样.有些直接定义为((void*)0),这样编译器不会为va_end产生代码,例如gcc在linux的x86平台就是这样定义的.在这里大家要注意一个问题:由于参数的地址用于va_start宏,所以参数不能声明为寄存器变量或作为函数或数组类型.关于va_start,&amp;nbsp;va_arg,&amp;nbsp;va_end的描述就是这些了,我们要注意的是不同的操作系统和硬件平台的定义有些不同,但原理却是相似的.
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		(三)可变参数在编程中要注意的问题
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		因为va_start,&amp;nbsp;va_arg,&amp;nbsp;va_end等定义成宏,所以它显得很愚蠢,可变参数的类型和个数完全在该函数中由程序代码控制,它并不能智能地识别不同参数的个数和类型.有人会问:那么printf中不是实现了智能识别参数吗?那是因为函数printf是从固定参数format字符串来分析出参数的类型,再调用va_arg的来获取可变参数的.也就是说,你想实现智能识别可变参数的话是要通过在自己的程序里作判断来实现的.另外有一个问题,因为编译器对可变参数的函数的原型检查不够严格,对编程查错不利.如果simple_va_fun()改为:
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		void&amp;nbsp;simple_va_fun(int&amp;nbsp;i,&amp;nbsp;...)
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		{
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		va_list&amp;nbsp;arg_ptr;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		char&amp;nbsp;*s=NULL;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		va_start(arg_ptr,&amp;nbsp;i);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		s=va_arg(arg_ptr,&amp;nbsp;char*);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		va_end(arg_ptr);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		printf(\"%d&amp;nbsp;%s\n\",&amp;nbsp;i,&amp;nbsp;s);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		return;
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		}
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		可变参数为char*型,当我们忘记用两个参数来调用该函数时,就会出现core&amp;nbsp;dump(Unix)&amp;nbsp;或者页面非法的错误(window平台).但也有可能不出错,但错误却是难以发现,不利于我们写出高质量的程序.
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		以下提一下va系列宏的兼容性.System&amp;nbsp;V&amp;nbsp;Unix把va_start定义为只有一个参数的宏:
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		va_start(va_list&amp;nbsp;arg_ptr);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		而ANSI&amp;nbsp;C则定义为:
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		va_start(va_list&amp;nbsp;arg_ptr,&amp;nbsp;prev_param);
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		如果我们要用system&amp;nbsp;V的定义,应该用vararg.h头文件中所定义的宏,ANSI&amp;nbsp;C的宏跟system&amp;nbsp;V的宏是不兼容的,我们一般都用ANSI&amp;nbsp;C,所以用ANSI&amp;nbsp;C的定义就够了,也便于程序的移植.
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		小结:
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		可变参数的函数原理其实很简单,而va系列是以宏定义来定义的,实现跟堆栈相关.我们写一个可变函数的C函数时,有利也有弊,所以在不必要的场合,我们无需用到可变参数.如果在C++里,我们应该利用C++的多态性来实现可变参数的功能,尽量避免用C语言的方式来实现.
	&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;lt;br&amp;nbsp;/&amp;gt;
	&amp;lt;/p&amp;gt;
&amp;lt;/p&amp;gt;</content>
<json-link>./file/c/2012-06-19/1340076077.json</json-link>
<comment-link>4</comment-link>
<tags>5</tags>
<imghref/>
<comment-list>
 <c>
  <author-c>1</author-c>
  <uid-c>2</uid-c>
  <date-c>2</date-c>
  <conf-c>3</conf-c>
  <locked>true</locked>
 </c>
</comment-list>
</root>
