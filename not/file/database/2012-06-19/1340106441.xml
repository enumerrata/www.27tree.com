<?xml version="1.0" encoding="UTF-8"?>
<root>
<title>建立索引提升MySQL查询速度</title>
<content>&amp;lt;p&amp;gt;
	索引是提高查询速度的最重要的工具。当然还有其它的一些技术可供使用，但是一般来说引起最大性能差异的都是索引的正确使用。在MySQL邮件列表中，人们经常询问那些让查询运行得更快的方法。在大多数情况下，我们应该怀疑数据表上有没有索引，并且通常在添加索引之后立即解决了问题。当然，并不总是这样简单就可以解决问题的，因为优化技术本来就并非总是简单的。然而，如果没有使用索引，在很多情况下，你试图使用其它的方法来提高性能都是在浪费时间。首先使用索引来获取最大的性能提高，接着再看其它的技术是否有用。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	这一部分讲述了索引是什么以及索引是怎么样提高查询性能的。它还讨论了在某些环境中索引可能降低性能，并为你明智地选择数据表的索引提供了一些指导方针。在下一部分中我们将讨论MySQL查询优化器，它试图找到执行查询的效率最高的方法。了解一些优化器的知识，作为对如何建立索引的补充，对我们是有好处的，因为这样你才能更好地利用自己所建立的索引。某些编写查询的方法实际上让索引不起作用，在一般情况下你应该避免这种情形的发生。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	索引的优点
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	让我们开始了解索引是如何工作的，首先有一个不带索引的数据表。不带索引的表仅仅是一个无序的数据行集合。例如，图1显示的ad表就是不带索引的表，因此如果需要查找某个特定的公司，就必须检查表中的每个数据行看它是否与目标值相匹配。这会导致一次完全的数据表扫描，这个过程会很慢，如果这个表很大，但是只包含少量的符合条件的记录，那么效率会非常低。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	[[The&amp;nbsp;No.1&amp;nbsp;Picture.]]
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	图1：无索引的ad表
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	图2是同样的一张数据表，但是增加了对ad表的company_num数据列的索引。这个索引包含了ad表中的每个数据行的条目，但是索引的条目是按照company_num值排序的。现在，我们不是逐行查看以搜寻匹配的数据项，而是使用索引。假设我们查找公司13的所有数据行。我们开始扫描索引并找到了该公司的三个值。接着我们碰到了公司14的索引值，它比我们正在搜寻的值大。索引值是排过序的，因此当我们读取了包含14的索引记录的时候，我们就知道再也不会有更多的匹配记录，可以结束查询操作了。因此使用索引获得的功效是：我们找到了匹配的数据行在哪儿终止，并能够忽略其它的数据行。另一个功效来自使用定位算法查找第一条匹配的条目，而不需要从索引头开始执行线性扫描（例如，二分搜索就比线性扫描要快一些）。通过使用这种方法，我们可以快速地定位第一个匹配的值，节省了大量的搜索时间。数据库使用了多种技术来快速地定位索引值，但是在本文中我们不关心这些技术。重点是它们能够实现，并且索引是个好东西。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	[[The&amp;nbsp;No.2&amp;nbsp;Picture.]]
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	图2：索引后的ad表
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	你可能要问，我们为什么不对数据行进行排序从而省掉索引？这样不是也能实现同样的搜索速度的改善吗？是的，如果表只有一个索引，这样做也可能达到相同的效果。但是你可能添加第二个索引，那么就无法一次使用两种不同方法对数据行进行排序了（例如，你可能希望在顾客名称上建立一个索引，在顾客ID号或电话号码上建立另外一个索引）。把与数据行相分离的条目作为索引解决了这个问题，允许我们创建多个索引。此外，索引中的行一般也比数据行短一些。当你插入或删除新的值的时候，移动较短的索引值比移动较长数据行的排序次序更加容易。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	不同的MySQL存储引擎的索引实现的具体细节信息是不同的。例如，对于MyISAM数据表，该表的数据行保存在一个数据文件中，索引值保存在索引文件中。一个数据表上可能有多个索引，但是它们都被存储在同一个索引文件中。索引文件中的每个索引都包含一个排序的键记录（它用于快速地访问数据文件）数组。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	与此形成对照的是，BDB和InnoDB存储引擎没有使用这种方法来分离数据行和索引值，尽管它们也把索引作为排序后的值集合进行操作。在默认情况下，BDB引擎使用单个文件存储数据和索引值。InnoDB使用单个数据表空间（tablespace），在表空间中管理所有InnoDB表的数据和索引存储。我们可以把InnoDB配置为每个表都在自己的表空间中创建，但是即使是这样，数据表的数据和索引也存储在同一个表空间文件中。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	前面的讨论描述了单个表查询环境下的索引的优点，在这种情况下，通过减少对整个表的扫描，使用索引明显地提高了搜索的速度。当你运行涉及多表联结（jion）查询的时候，索引的价值就更高了。在单表查询中，你需要在每个数据列上检查的值的数量是表中数据行的数量。在多表查询中，这个数量可能大幅度上升，因为这个数量是这些表中数据行的数量所产生的。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	假设你拥有三个未索引的表t1、t2和t3，每个表都分别包含数据列i1、i2和i3，并且每个表都包含了1000条数据行，其序号从1到1000。查找某些值匹配的数据行组合的查询可能如下所示：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	SELECT&amp;nbsp;t1.i1,&amp;nbsp;t2.i2,&amp;nbsp;t3.i3
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	FROM&amp;nbsp;t1,&amp;nbsp;t2,&amp;nbsp;t3
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	WHERE&amp;nbsp;t1.i1&amp;nbsp;=&amp;nbsp;t2.i2&amp;nbsp;AND&amp;nbsp;t2.i1&amp;nbsp;=&amp;nbsp;t3.i3;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	这个查询的结果应该是1000行，每个数据行包含三个相等的值。如果在没有索引的情况下处理这个查询，那么如果我们不对这些表进行全部地扫描，我们是没有办法知道哪些数据行含有哪些值的。因此你必须尝试所有的组合来查找符合WHERE条件的记录。可能的组合的数量是1000&amp;nbsp;x&amp;nbsp;1000&amp;nbsp;x&amp;nbsp;1000（10亿！），它是匹配记录的数量的一百万倍。这就浪费了大量的工作。这个例子显示，如果没有使用索引，随着表的记录不断增长，处理这些表的联结所花费的时间增长得更快，导致性能很差。我们可以通过索引这些数据表来显著地提高速度，因为索引让查询采用如下所示的方式来处理：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	1．选择表t1中的第一行并查看该数据行的值。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	2．使用表t2上的索引，直接定位到与t1的值匹配的数据行。类似地，使用表t3上的索引，直接定位到与表t2的值匹配的数据行。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	3．处理表t1的下一行并重复前面的过程。执行这样的操作直到t1中的所有数据行都被检查过。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	在这种情况下，我们仍然对表t1执行了完整的扫描，但是我们可以在t2和t3上执行索引查找，从这些表中直接地获取数据行。理论上采用这种方式运行上面的查询会快一百万倍。当然这个例子是为了得出结论来人为建立的。然而，它解决的问题却是现实的，给没有索引的表添加索引通常会获得惊人的性能提高。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	MySQL有几种使用索引的方式：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;如上所述，索引被用于提高WHERE条件的数据行匹配或者执行联结操作时匹配其它表的数据行的搜索速度。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;对于使用了MIN()或MAX()函数的查询，索引数据列中最小或最大值可以很快地找到，不用检查每个数据行。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;MySQL利用索引来快速地执行ORDER&amp;nbsp;BY和GROUP&amp;nbsp;BY语句的排序和分组操作。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;有时候MySQL会利用索引来读取查询得到的所有信息。假设你选择了MyISAM表中的被索引的数值列，那么就不需要从该数据表中选择其它的数据列。在这种情况下，MySQL从索引文件中读取索引值，它所得到的值与读取数据文件得到的值是相同的。没有必要两次读取相同的值，因此没有必要考虑数据文件。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	索引的代价
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	一般来说，如果MySQL能够找到方法，利用索引来更快地处理查询，它就会这样做。这意味着，对于大多数情况，如果你没有对表进行索引，就会使性能受到损害。这就是我所描绘的索引优点的美景。但是它有缺点吗？有的，它在时间和空间上都有开销。在实践中，索引的优点的价值一般会超过这些缺点，但是你也应该知道到底有一些什么缺点。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	首先，索引加快了检索的速度，但是减慢了插入和删除的速度，同时还减慢了更新被索引的数据列中的值的速度。也就是说，索引减慢了大多数涉及写操作的速度。发生这种现象的原因在于写入一条记录的时候不但需要写入数据行，还需要改变所有的索引。数据表带有的索引越多，需要做出的修改就越多，平均性能的降低程度也就越大。在本文的\"高效率载入数据\"部分中，我们将更细致地了解这些现象并找出处理方法。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	其次，索引会花费磁盘空间，多个索引相应地花费更多的磁盘空间。这可能导致更快地到达数据表的大小限制：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;对于MyISAM表，频繁地索引可能引起索引文件比数据文件更快地达到最大限制。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;对于BDB表，它把数据和索引值一起存储在同一个文件中，添加索引引起这种表更快地达到最大文件限制。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	·&amp;nbsp;在InnoDB的共享表空间中分配的所有表都竞争使用相同的公共空间池，因此添加索引会更快地耗尽表空间中的存储。但是，与MyISAM和BDB表使用的文件不同，InnoDB共享表空间并不受操作系统的文件大小限制，因为我们可以把它配置成使用多个文件。只要有额外的磁盘空间，你就可以通过添加新组件来扩展表空间。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	使用单独表空间的InnoDB表与BDB表受到的约束是一样的，因为它的数据和索引值都存储在单个文件中。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	这些要素的实际含义是：如果你不需要使用特殊的索引帮助查询执行得更快，就不要建立索引。
&amp;lt;/p&amp;gt;</content>
<json-link>./file/database/2012-06-19/1340106441.json</json-link>
<comment-link>4</comment-link>
<tags>5</tags>
<imghref/>
<comment-list>
 <c>
  <author-c>1</author-c>
  <uid-c>2</uid-c>
  <date-c>2</date-c>
  <conf-c>3</conf-c>
  <locked>true</locked>
 </c>
</comment-list>
</root>
