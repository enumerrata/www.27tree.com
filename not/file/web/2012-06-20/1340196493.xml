<?xml version="1.0" encoding="UTF-8"?>
<root>
<title>JavaScript之UI线程的性能影响</title>
<content>&amp;lt;p&amp;gt;
	没有什么比点击页面上的东西却什么也没发生更令人感到挫折了。这个问题又回到了原始网页交互程序和现在已无处不在的提交表单时弹出的“请勿重复提交”消息&amp;nbsp;上面。用户自然倾向于重复尝试这些不发生明显变化的动作，所以确保网页应用程序的响应速度也是一个重要的性能关注点。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	总的来说，大多数浏览器有一个单独的处理进程，它由两个任务所共享：JavaScript任务和用户界面更新任务。每个时刻只有其中的一个操作得以执行，&amp;nbsp;也就是说当JavaScript代码运行时用户界面不能对输入产生反应，反之亦然。或者说，当JavaScript运行时，用户界面就被“锁定”了。管理&amp;nbsp;好JavaScript运行时间对网页应用的性能很重要。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	一、浏览器UI&amp;nbsp;线程&amp;nbsp;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	JavaScript和UI更新共享的进程通常被称作浏览器UI线程（虽然对所有浏览器来说“线程”一词不一定准确）。此UI线程围绕着一个简单的队列系&amp;nbsp;统工作，任务被保存到队列中直至进程空闲。一旦空闲，队列中的下一个任务将被检索和运行。这些任务不是运JavaScript代码，就是执行UI更新，包&amp;nbsp;括重绘和重排版。此进程中最令人感兴趣的部分是每次输入均导致一个或多个任务被加入队列。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	考虑这样一个简单的接口：按下一个按钮，然后屏幕上显示出一个消息：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;html&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;head&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;title&amp;amp;gt;Browser&amp;nbsp;UI&amp;nbsp;Thread&amp;nbsp;Example&amp;amp;lt;/title&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;/head&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;body&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;button&amp;nbsp;onclick=handleClick()&amp;amp;gt;Click&amp;nbsp;Me&amp;amp;lt;/button&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;script&amp;nbsp;type=text/javascript&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	function&amp;nbsp;handleClick(){
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	var&amp;nbsp;div&amp;nbsp;=&amp;nbsp;document.createElement(div);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	div.innerHTML&amp;nbsp;=&amp;nbsp;Clicked!;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	document.body.appendChild(div);
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	}
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;/script&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;/body&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	&amp;amp;lt;/html&amp;amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	当例子中的按钮被点击时，它触发UI&amp;nbsp;线程创建两个任务并添加到队列中。第一个任务是按钮的UI&amp;nbsp;更新，它需要改变外观以指示出它被按下了，第二个任务是JavaScript运行任务，包含handleClick()的代码，被运行的唯一代码就是这个&amp;nbsp;方法和所有被它调用的方法。假设UI&amp;nbsp;线程空闲，第一个任务被检查并运行以更新按钮外观，然后JavaScript任务被检查和运行。在运行过程中，handleClick()创建了一个新&amp;nbsp;的&amp;amp;lt;div&amp;amp;gt;元素，并追加在&amp;amp;lt;body&amp;amp;gt;元素上，其效果是引发另一次UI改变。也就是说在JavaScript运行过程中，一个&amp;nbsp;新的UI更新任务被添加在队列中，当JavaScript运行完之后，UI还会再更新一次。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	当所有UI&amp;nbsp;线程任务执行之后，进程进入空闲状态，并等待更多任务被添加到队列中。空闲状态是理想的，因为所有用户操作立刻引发一次UI更新。如果用户企图在任务运行&amp;nbsp;时与页面交互，不仅没有即时的UI更新，而且不会有新的UI&amp;nbsp;更新任务被创建和加入队列。事实上，大多数浏览器在JavaScript运行时停止UI线程队列中的任务，也就是说JavaScript任务必须尽快结&amp;nbsp;束，以免对用户体验造成不良影响。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	二、浏览器限制
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	浏览器在JavaScript运行时间上采取了限制。这是一个有必要的限制，确保恶意代码编写者不能通过无尽的密集操作锁定用户浏览器或计算机。此类限制&amp;nbsp;有两个：调用栈尺寸限制（第四章讨论过）和长时间脚本限制。长运行脚本限制有时被称作长运行脚本定时器或者失控脚本定时器，但其基本思想是浏览器记录一个&amp;nbsp;脚本的运行时间，一旦到达一定限度时就终止它。当此限制到达时，浏览器会向用户显示一个对话框。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	有两种方法测量脚本的运行时间。第一个方法是统计自脚本开始运行以来执行过多少语句。此方法意味着脚本在不同的机器上可能会运行不同的时间长度，可用内存&amp;nbsp;和CPU&amp;nbsp;速度可以影响一条独立语句运行所花费的时间。第二种方法是统计脚本运行的总时间。在特定时间内可运行的脚本数量也因用户机器性能差异而不同，但脚本总是停&amp;nbsp;在固定的时间上。毫不奇怪，每个浏览器对长运行脚本检查方法上略有不同：
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	（1）Internet&amp;nbsp;Explorer，在第4版中，设置默认限制为5百万条语句；此限制存放在Windows&amp;nbsp;注册表中，叫做HKEY_CURRENT_USER\Software\Microsoft\InternetExplorer\Styles&amp;nbsp;\MaxScriptStatements
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	（2）Firefox&amp;nbsp;默认限制为10&amp;nbsp;秒钟，此限制存放在浏览器的配置设置中（在地址栏中输入about:config）键名为
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	dom.max_script_run_time。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	（3）Safari&amp;nbsp;默认限制为5&amp;nbsp;秒钟，此设置不能改变，但你可以关闭此定时，通过启动Develop&amp;nbsp;菜单并选择“禁止失控JavaScript定时器”。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	（4）Chrome&amp;nbsp;没有独立的长运行脚本限制，替代以依赖它的通用崩溃检测系统来处理此类实例。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	（5）Opera&amp;nbsp;没有长运行脚本限制，将继续运行JavaScript代码直至完成，由于Opera&amp;nbsp;的结构，当运行结束时它并不会导致系统不稳定。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	当浏览器的长时间脚本限制被触发时，有一个对话框显示给用户，而不管页面上的任何其他错误处理代码。这是一个主要的可用性问题，因为大多数互联网用户并不精通技术，会被错误信息所迷惑，不知道应该选择哪个选项（停止脚本或允许它继续运行）。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	如果你的脚本在浏览器上触发了此对话框，意味着脚本只是用太长的时间来完成任务。它还表明用户浏览器在JavaScript代码继续运行状态下无法响应输&amp;nbsp;入。从开发者观点看，没有办法改变长运行脚本对话框的外观，你不能检测到它，因此不能用它来提示可能出现的问题。显然，长运行脚本最好的处理办法首先是避&amp;nbsp;免它们。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	三、多久才算“太久”？
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	浏览器允许脚本继续运行直至某个固定的时间，这并不意味着你可以允许它这样做。事实上，你JavaScript代码持续运行的总时间应当远小于浏览器实施的限制，以创建良好的用户体验。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	如果整整几秒钟对JavaScript运行来说太长了，那么什么是适当的时间？事实证明，即使一秒钟对脚本运行来说也太长了。一个单一的&amp;nbsp;JavaScript操作应当使用的总时间（最大）是100&amp;nbsp;毫秒。这个数字根据RobertMiller&amp;nbsp;在1968&amp;nbsp;年的研究。有趣的是，可用性专家Jakob&amp;nbsp;Nielsen&amp;nbsp;在他的著作《可用性工程》（Morgan&amp;nbsp;Kaufmann，1944）上注释说这一数字并没有因时间的推移而改变，而且事实上在1991&amp;nbsp;年被Xerox-PARC（施乐公司的
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	帕洛阿尔托研究中心）的研究中重申。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	Nielsen指出如果该接口在100&amp;nbsp;毫秒内响应用户输入，用户认为自己是“直接操作用户界面中的对象。”超过100&amp;nbsp;毫秒意味着用户认为自己与接口断开了。由于UI&amp;nbsp;在JavaScript运行时无法更新，如果运行时间长于100&amp;nbsp;毫秒，用户就不能感受到对接口的控制。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	更复杂的是有些浏览器在JavaScript运行时不将UI&amp;nbsp;更新放入队列。例如，如果你在某些JavaScript代码运行时点击按钮，浏览器可能不会将重绘按钮按下的UI&amp;nbsp;更新任务放入队列，也不会放入由这个按钮启动的JavaScript任务。其结果是一个无响应的UI，表现为“挂起”或“冻结”。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	每种浏览器的行为大致相同。当脚本执行时，UI&amp;nbsp;不随用户交互而更新。此时JavaScript任务作为用户交互的结果被创建被放入队列，然后当原始JavaScript任务完成时队列中的任务被执行。&amp;nbsp;用户交互导致的UI更新被自动跳过，因为优先考虑的是页面上的动态部分。因此，当一个脚本运行时点击一个按钮，将看不到它被按下的样子，即使它的&amp;nbsp;onclick句柄被执行了。
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
	尽管浏览器尝试在这些情况下做一些符合逻辑的事情，但所有这些行为导致了一个间断的用户体验。因此最好的方法是，通过限制任何JavaScript任务在100毫秒或更少时间内完成，避免此类情况出现。
&amp;lt;/p&amp;gt;</content>
<json-link>./file/web/2012-06-20/1340196493.json</json-link>
<comment-link>4</comment-link>
<tags>5</tags>
<imghref/>
<comment-list>
 <c>
  <author-c>1</author-c>
  <uid-c>2</uid-c>
  <date-c>2</date-c>
  <conf-c>3</conf-c>
  <locked>true</locked>
 </c>
</comment-list>
</root>
