<?xml version="1.0" encoding="UTF-8"?>
<root>
  <uid>32</uid>
  <datetime>2013-01-06 23:56:32</datetime>
  <title><![CDATA[Java垃圾收集算法]]></title>
  <content><![CDATA[<p>
	<strong>1.Java垃圾收集算法的核心思想</strong>
</p>
<p>
	Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。Java垃圾回收算法可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。
</p>
<p>
	垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能，因此需要开发人员做比较深入的了解。
</p>
<p>
	<strong>2.触发主GC的条件</strong>
</p>
<p>
	JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:
</p>
<p>
	①当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。
</p>
<p>
	②Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。
</p>
<p>
	由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。
</p>
<p>
	<strong>3.减少GC开销的措施</strong>
</p>
<p>
	根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:
</p>
<p>
	(1)不要显式调用System.gc()
</p>
<p>
	此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。
</p>
<p>
	(2)尽量减少临时对象的使用
</p>
<p>
	临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。
</p>
<p>
	(3)对象不用时最好显式置为Null
</p>
<p>
	一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。
</p>
<p>
	(4)尽量使用StringBuffer,而不用String来累加字符串(详见blog另一篇文章JAVA中String与StringBuffer)
</p>
<p>
	由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。
</p>
<p>
	(5)能用基本类型如Int,Long,就不用Integer,Long对象
</p>
<p>
	基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。
</p>
<p>
	(6)尽量少用静态对象变量
</p>
<p>
	静态变量属于全局变量,不会被GC回收,它们会一直占用内存。
</p>
<p>
	(7)分散对象创建或删除的时间
</p>
<p>
	集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。可以说基于Java垃圾回收算法的GC机制有效的减少了Java在内存管理方面的错误。
</p>]]></content>
  <contentx><![CDATA[1.Java垃圾收集算法的核心思想


	Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。Java垃圾回收算法可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。


	垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对]]></contentx>
  <tags>_null_</tags>
  <parseVersion>1.1</parseVersion>
</root>
