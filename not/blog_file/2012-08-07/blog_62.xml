<?xml version="1.0" encoding="UTF-8"?>
<root>
  <uid>19</uid>
  <datetime>2012-08-07 14:23:24</datetime>
  <title>PHP 会话(session 时间设定)使用入门</title>
  <content>&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	在PHP开发中对比起Cookie，Session
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	是存储在服务器端的会话，相对安全，并且不像&amp;nbsp;Cookie&amp;nbsp;那样有存储长度限制，本文简单介绍&amp;nbsp;Session&amp;nbsp;的使用。
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	由于&amp;nbsp;Session&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;是以文本文件形式存储在服务器端的，所以不怕客户端修改&amp;nbsp;Session&amp;nbsp;内容。实际上在服务器端的&amp;nbsp;Session&amp;nbsp;文件，PHP&amp;nbsp;自动修改&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;文件的权限，只保留了系统读和写权限，而且不能通过&amp;nbsp;ftp&amp;nbsp;修改，所以安全得多。PHPChina&amp;nbsp;开源社区门户k%W%e2CY&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	对于&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Cookie&amp;nbsp;来说，假设我们要验证用户是否登陆，就必须在&amp;nbsp;Cookie&amp;nbsp;中保存用户名和密码（可能是&amp;nbsp;md5&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;加密后字符串），并在每次请求页面的时候进行验证。如果用户名和密码存储在数据库，每次都要执行一次数据库查询，给数据库造成多余的负担。因为我们并不能&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;只做一次验证。为什么呢？因为客户端&amp;nbsp;Cookie&amp;nbsp;中的信息是有可能被修改的。假如你存储&amp;nbsp;$admin&amp;nbsp;变量来表示用户是否登陆，$admin&amp;nbsp;为&amp;nbsp;true&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;的时候表示登陆，为&amp;nbsp;false&amp;nbsp;的时候表示未登录，在第一次通过验证后将&amp;nbsp;$admin&amp;nbsp;等于&amp;nbsp;true&amp;nbsp;存储在&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Cookie，下次就不用验证了，这样对么？错了，假如有人伪造一个值为&amp;nbsp;true&amp;nbsp;的&amp;nbsp;$admin&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;变量那不是就立即取的了管理权限么？非常的不安全。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	而&amp;nbsp;Session&amp;nbsp;就不同了，Session&amp;nbsp;是存储在服务器端的，远程用户没办法修改
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	Session&amp;nbsp;文件的内容，因此我们可以单纯存储一个&amp;nbsp;$admin&amp;nbsp;变量来判断是否登陆，首次验证通过后设置&amp;nbsp;$admin&amp;nbsp;值为&amp;nbsp;true，以后判断该值是否为&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;true，假如不是，转入登陆界面，这样就可以减少很多数据库操作了。而且可以减少每次为了验证&amp;nbsp;Cookie&amp;nbsp;而传递密码的不安全性了（Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;验证只需要传递一次，假如你没有使用&amp;nbsp;SSL&amp;nbsp;安全协议的话）。即使密码进行了&amp;nbsp;md5&amp;nbsp;加密，也是很容易被截获的。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	当然使用&amp;nbsp;Session&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;还有很多优点，比如控制容易，可以按照用户自定义存储等（存储于数据库）。我这里就不多说了。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	Session&amp;nbsp;在&amp;nbsp;php.ini&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;是否需要设置呢？一般不需要的，因为并不是每个人都有修改&amp;nbsp;php.ini&amp;nbsp;的权限，默认&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;的存放路径是服务器的系统临时文件夹，我们可以自定义存放在自己的文件夹里，这个稍后我会介绍。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	开始介绍如何创建
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	Session。非常简单，真的。
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	启动&amp;nbsp;Session&amp;nbsp;会话，并创建一个&amp;nbsp;$admin&amp;nbsp;变量：
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	＜?php
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	//&amp;nbsp;启动&amp;nbsp;Session
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	session_start();
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	//&amp;nbsp;声明一个名为&amp;nbsp;admin&amp;nbsp;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;的变量，并赋空值。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	$_SESSION[\"admin\"]&amp;nbsp;=&amp;nbsp;null;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	?＞
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	如果你使用了&amp;nbsp;Seesion，或者该&amp;nbsp;PHP&amp;nbsp;文件要调用&amp;nbsp;Session&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;变量，那么就必须在调用&amp;nbsp;Session&amp;nbsp;之前启动它，使用&amp;nbsp;session_start()&amp;nbsp;函数。其它都不需要你设置了，PHP&amp;nbsp;自动完成&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;文件的创建。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	执行完这个程序后，我们可以到系统临时文件夹找到这个&amp;nbsp;Session&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;文件，一般文件名形如：sess_4c83638b3b0dbf65583181c2f89168ec，后面是&amp;nbsp;32&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;位编码后的随机字符串。用编辑器打开它，看一下它的内容：&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	admin|N;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	一般该内容是这样的结构：
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	变量名|类型:长度:值;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;并用分号隔开每个变量。有些是可以省略的，比如长度和类型。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	我们来看一下验证程序，假设数据库存储的是用户名和&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;md5&amp;nbsp;加密后的密码：&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
//&amp;nbsp;表单提交后...
$posts&amp;nbsp;=&amp;nbsp;$_POST;
//&amp;nbsp;清除一些空白符号
foreach
($posts&amp;nbsp;as&amp;nbsp;$key&amp;nbsp;=＞&amp;nbsp;$value)
{
$posts[$key]&amp;nbsp;=&amp;nbsp;trim($value);
}
$password&amp;nbsp;=&amp;nbsp;md5($posts[\"password\"]);
$username&amp;nbsp;=&amp;nbsp;$posts[\"username\"];
$query&amp;nbsp;=&amp;nbsp;\"SELECT&amp;nbsp;`username`&amp;nbsp;FROM&amp;nbsp;`user`&amp;nbsp;WHERE&amp;nbsp;`password`&amp;nbsp;=&amp;nbsp;&amp;nbsp;$password&amp;nbsp;\";
//&amp;nbsp;取得查询结果
$userInfo&amp;nbsp;=&amp;nbsp;$DB-＞getRow($query);
if
(!empty($userInfo))
{
if&amp;nbsp;($userInfo[\"username\"]&amp;nbsp;==&amp;nbsp;$username)
{
//&amp;nbsp;当验证通过后，启动&amp;nbsp;Session
session_start();
//&amp;nbsp;注册登陆成功的&amp;nbsp;admin&amp;nbsp;变量，并赋值&amp;nbsp;true
$_SESSION[\"admin\"]&amp;nbsp;=&amp;nbsp;true;
}
else
{
die(\"用户名密码错误\");
}
}
else
{
die(\"用户名密码错误\");
}&lt;/pre&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	我们在需要用户验证的页面启动&amp;nbsp;Session，判断是否登陆：
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
//&amp;nbsp;防止全局变量造成安全隐患
$admin&amp;nbsp;=&amp;nbsp;false;
//&amp;nbsp;启动会话，这步必不可少
session_start();
//&amp;nbsp;判断是否登陆
if&amp;nbsp;(isset($_SESSION[\"admin\"])
&amp;&amp;&amp;nbsp;$_SESSION[\"admin\"]&amp;nbsp;===&amp;nbsp;true)
{
echo&amp;nbsp;\"您已经成功登陆\";
}
else
{
//&amp;nbsp;验证失败，将&amp;nbsp;$_SESSION[\"admin\"]&amp;nbsp;置为&amp;nbsp;false
$_SESSION[\"admin\"]&amp;nbsp;=&amp;nbsp;false;
die(\"您无权访问\");
}
?＞&lt;/pre&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	是不是很简单呢？将&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;$_SESSION&amp;nbsp;看成是存储在服务器端的数组即可，我们注册的每一个变量都是数组的键，跟使用数组没有什么分别。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	如果要登出系统怎么办？销毁&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Session&amp;nbsp;即可。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
session_start();
//
这种方法是将原来注册的某个变量销毁
unset($_SESSION[\"admin\"]);
//&amp;nbsp;这种方法是销毁整个&amp;nbsp;Session
文件
session_destroy();
＞&lt;/pre&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	Session&amp;nbsp;能否像&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Cookie&amp;nbsp;那样设置生存周期呢？有了&amp;nbsp;Session&amp;nbsp;是否就完全抛弃&amp;nbsp;Cookie&amp;nbsp;呢？我想说，结合&amp;nbsp;Cookie&amp;nbsp;来使用&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;才是最方便的。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	Session&amp;nbsp;是如何来判断客户端用户的呢？它是通过&amp;nbsp;Session&amp;nbsp;ID&amp;nbsp;来判断的，什么是&amp;nbsp;Session&amp;nbsp;ID，就是那个&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Session&amp;nbsp;文件的文件名，Session&amp;nbsp;ID&amp;nbsp;是随机生成的，因此能保证唯一性和随机性，确保&amp;nbsp;Session&amp;nbsp;的安全。一般如果没有设置&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;的生存周期，则&amp;nbsp;Session&amp;nbsp;ID&amp;nbsp;存储在内存中，关闭浏览器后该&amp;nbsp;ID&amp;nbsp;自动注销，重新请求该页面后，重新注册一个&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;ID。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	　　如果客户端没有禁用&amp;nbsp;Cookie，则&amp;nbsp;Cookie&amp;nbsp;在启动&amp;nbsp;Session&amp;nbsp;会话的时候扮演的是存储&amp;nbsp;Session&amp;nbsp;ID&amp;nbsp;和&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Session&amp;nbsp;生存期的角色。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	我们来手动设置&amp;nbsp;Session&amp;nbsp;的生存期：
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
session_start();
//&amp;nbsp;保存一天
$lifeTime&amp;nbsp;=&amp;nbsp;24&amp;nbsp;*&amp;nbsp;3600;
setcookie(session_name(),&amp;nbsp;session_id(),&amp;nbsp;time()&amp;nbsp;+&amp;nbsp;$lifeTime,&amp;nbsp;\"/\");
?＞&lt;/pre&gt;
	&lt;p&gt;
		其实&amp;nbsp;Session&amp;nbsp;还提供了一个函数&amp;nbsp;session_set_cookie_params();&amp;nbsp;来设置&amp;nbsp;Session&amp;nbsp;的生存期的，该函数必须在&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;session_start()&amp;nbsp;函数调用之前调用：&lt;/span&gt;
	&lt;/p&gt;
	&lt;p&gt;
		&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php&amp;nbsp;

//&amp;nbsp;保存一天&amp;nbsp;
$lifeTime&amp;nbsp;=&amp;nbsp;24&amp;nbsp;*&amp;nbsp;3600;&amp;nbsp;
session_set_cookie_params($lifeTime);&amp;nbsp;
session_start();
$_SESSION[\"admin\"]&amp;nbsp;=&amp;nbsp;true;&amp;nbsp;
?＞&lt;/pre&gt;
&lt;/span&gt;
	&lt;/p&gt;
&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;如果客户端使用&amp;nbsp;IE&amp;nbsp;6.0&amp;nbsp;，&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;session_set_cookie_params();&amp;nbsp;函数设置&amp;nbsp;Cookie&amp;nbsp;会有些问题，所以我们还是手动调用&amp;nbsp;setcookie&amp;nbsp;函数来创建&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;cookie。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	假设客户端禁用&amp;nbsp;Cookie&amp;nbsp;怎么办？没办法，所有生存周期都是浏览器进程了，只要关闭浏览器，再次请求页面又得重新注册&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;Session。那么怎么传递&amp;nbsp;Session&amp;nbsp;ID&amp;nbsp;呢？通过&amp;nbsp;URL&amp;nbsp;或者通过隐藏表单来传递，PHP&amp;nbsp;会自动将&amp;nbsp;Session&amp;nbsp;ID&amp;nbsp;发送到&amp;nbsp;URL&amp;nbsp;上，URL&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;形如：http://www.openphp.cn/index.php?PHPSESSID=bba5b2a240a77e5b44cfa01d49cf9669，其中&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;URL&amp;nbsp;中的参数&amp;nbsp;PHPSESSID&amp;nbsp;就是&amp;nbsp;Session&amp;nbsp;ID了，我们可以使用&amp;nbsp;$_GET&amp;nbsp;来获取该值，从而实现&amp;nbsp;Session&amp;nbsp;ID&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;页面间传递。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
//&amp;nbsp;保存一天
$lifeTime&amp;nbsp;=&amp;nbsp;24&amp;nbsp;*&amp;nbsp;3600;
//&amp;nbsp;取得当前&amp;nbsp;Session&amp;nbsp;名，默认为
PHPSESSID
$sessionName&amp;nbsp;=&amp;nbsp;session_name();
//&amp;nbsp;取得&amp;nbsp;Session&amp;nbsp;ID
$sessionID
=&amp;nbsp;$_GET[$sessionName];
//&amp;nbsp;使用&amp;nbsp;session_id()&amp;nbsp;设置获得的&amp;nbsp;Session&amp;nbsp;ID
session_id($sessionID);
session_set_cookie_params($lifeTime);
session_start();
$_SESSION[\"admin\"]&amp;nbsp;=
true;
?＞&lt;/pre&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	对于虚拟主机来说，如果所有用户的&amp;nbsp;Session&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;都保存在系统临时文件夹里，将给维护造成困难，而且降低了安全性，我们可以手动设置&amp;nbsp;Session&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;文件的保存路径，session_save_path()就提供了这样一个功能。我们可以将&amp;nbsp;Session&amp;nbsp;存放目录指向一个不能通过&amp;nbsp;Web&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;方式访问的文件夹，当然，该文件夹必须具备可读写属性。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
//&amp;nbsp;设置一个存放目录
$savePath&amp;nbsp;=&amp;nbsp;\"./session_save_dir/\";
//&amp;nbsp;保存一天
$lifeTime&amp;nbsp;=&amp;nbsp;24&amp;nbsp;*&amp;nbsp;3600;
session_save_path($savePath);
session_set_cookie_params($lifeTime);
session_start();
$_SESSION[\"admin\"]&amp;nbsp;=&amp;nbsp;true;
?＞&lt;/pre&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	同&amp;nbsp;session_set_cookie_params();&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;函数一样，session_save_path()&amp;nbsp;函数也必须在&amp;nbsp;session_start()&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;函数调用之前调用。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	我们还可以将数组，对象存储在&amp;nbsp;Session&amp;nbsp;中。操作数组和操作一般变量没有什么区别，而保存对象的话，PHP&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;会自动对对象进行序列化（也叫串行化），然后保存于&amp;nbsp;Session&amp;nbsp;中。下面例子说明了这一点：&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
&lt;pre&amp;nbsp;name=\"code\"&amp;nbsp;id=\"prettyprint\"&amp;nbsp;class=\"PHP\"&gt;＜?php
class&amp;nbsp;person
{
var&amp;nbsp;$age;
function&amp;nbsp;output()&amp;nbsp;{
echo
$this-＞age;
}
function&amp;nbsp;setAge($age)&amp;nbsp;{
$this-＞age&amp;nbsp;=&amp;nbsp;$age;
}
}
?＞
setage.php
＜?php
session_start();
require_once
\"person.php\";
$person&amp;nbsp;=&amp;nbsp;new&amp;nbsp;person();
$person-＞setAge(21);
$_SESSION[&amp;nbsp;person&amp;nbsp;]&amp;nbsp;=&amp;nbsp;$person;
echo&amp;nbsp;\"＜a
href=&amp;nbsp;output&amp;nbsp;＞check&amp;nbsp;here&amp;nbsp;to&amp;nbsp;output&amp;nbsp;age＜/a＞\";
?＞
output.php
＜?
//
设置回调函数，确保重新构建对象。
ini_set(&amp;nbsp;unserialize_callback_func&amp;nbsp;,&amp;nbsp;&amp;nbsp;mycallback&amp;nbsp;);
function&amp;nbsp;mycallback($classname)&amp;nbsp;{
$classname&amp;nbsp;.&amp;nbsp;\".php\";
}
session_start();
$person&amp;nbsp;=&amp;nbsp;$_SESSION[\"person\"];
//&amp;nbsp;输出&amp;nbsp;21
$person-＞output();
?＞&lt;/pre&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	当我们执行&amp;nbsp;setage.php&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;文件的时候，调用了&amp;nbsp;setage()&amp;nbsp;方法，设置了年龄为&amp;nbsp;21，并将该状态序列化后保存在&amp;nbsp;Session&amp;nbsp;中（PHP&amp;nbsp;将自动完成这一转换），当转到&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;output.php&amp;nbsp;后，要输出这个值，就必须反序列化刚才保存的对象，又因为在解序列化的时候需要实例化一个未定义类，所以我们定义了以后回调函数，自动包含&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;person.php&amp;nbsp;这个类文件，因此对象被重构，并取得当前&amp;nbsp;age&amp;nbsp;的值为&amp;nbsp;21，然后调用&amp;nbsp;output()&lt;/span&gt;&lt;span&amp;nbsp;style=\"text-indent:2em;\"&gt;方法输出该值。&lt;/span&gt;
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	另外，我们还可以使用&amp;nbsp;session_set_save_handler&amp;nbsp;函数来自定义&amp;nbsp;Session&amp;nbsp;的调用方式。
&lt;/p&gt;
&lt;p&amp;nbsp;style=\"text-indent:2em;\"&gt;
	&lt;br&amp;nbsp;/&gt;
&lt;/p&gt;</content>
  <contentx>在PHP开发中对比起Cookie，Session


	是存储在服务器端的会话，相对安全，并且不像 Cookie 那样有存储长度限制，本文简单介绍 Session 的使用。


	由于 Session是以文本文件形式存储在服务器端的，所以不怕客户端修改 Session 内容。实际上在服务器端的 Session 文件，PHP 自动修改 Session文件的权限</contentx>
  <tags>_null_</tags>
</root>
